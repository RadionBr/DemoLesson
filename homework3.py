# ДЗ 11.3. Перевірка на парність.
# Завдання ускладнюється.
# Ваша функція is_even, як і раніше, повинна повертати True якщо число парне,
# або False якщо число непарне, але при цьому НЕ МОЖНА використовувати ділення у функції,
# та дії пов'язані з ним. Тобто. заборонено використовувати /, //, % та divmod
# Складність ще полягає і в тому, щоб знайти рішення, яке не залежало б від розміру числа :)
# Вхідні дані: Ціле число.
# Вихідні дані: True або False
#
# def is_even(number):
#     pass
#
# assert is_even(2494563894038**2) == True, 'Test1'
# assert is_even(1056897**2) == False, 'Test2'
# assert is_even(24945638940387**3) == False, 'Test3'

'''
можна скористатися побітовими операціями. Найпростішим методом є використання побітового оператора AND з числом 1.
Якщо останній біт числа дорівнює 0, то число парне, а якщо дорівнює 1 — непарне.
Побітовий оператор AND дозволяє ефективно визначити значення останнього біта числа.
'''

def is_even(number):
    # Використовуємо побітовий оператор AND з числом 1
    return (number & 1) == 0

# Тести для перевірки функції
assert is_even(2494563894038**2) == True, 'Test1'
assert is_even(1056897**2) == False, 'Test2'
assert is_even(24945638940387**3) == False, 'Test3'

print('Ok 01010011')